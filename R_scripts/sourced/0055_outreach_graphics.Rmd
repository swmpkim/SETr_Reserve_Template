---
title: "SET Outreach Tools"
date: "`r Sys.Date()`"
output: word_document
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, error = TRUE)
```

```{r load-libraries}
library(knitr)
library(forcats)
library(readr)
library(janitor)
library(dplyr)
library(tidyr)
library(ggplot2)
library(here)
library(flextable)
library(readxl)
library(lubridate)
library(leaflet)
# load functions
source(here::here('R_scripts', 'sourced', '000_functions.R'))
# load user options
source(here::here('R_scripts', 'sourced', '001_user_options.R'))
```

# Background - National level  

This document is intended for use as an outreach tool to help National Estuarine Research Reserve (NERR) Education and Coastal Training Program staff present and describe information relating to Surface Elevation Table (SET) data. These products are output from a 2018-2019 NERRS Science Collaborative Catalyst Grant project nicknamed "SETr".  

The NERR Sentinel Site Program is an integrated set of System-Wide Monitoring Program (SWMP) data on water level and vegetation characteristics combined with elevation measurements used to assess the impacts of changes in sea level. Surface Elevation Table (SET) technology, a means of measuring height of the marsh substrate, is a key component of the NERRS Sentinel Site Program. In this project, the acquired NERRS Sentinel Site SET data is analyzed to answer the question – Are marsh vegetation communities keeping pace with sea level rise. Note that this is an analysis looking backwards in time; it is not a forecast.

A Surface Elevation Table (SET) is a specially machined apparatus designed to attach atop a rod driven into the ground as deeply as possible (point of refusal).  A receiver is attached to the rod and permanently cast in a cement collar (referenced as #1 ‘SET mark’ in Figure 1). The SET apparatus consists of a vertical stand, which attaches to the receiver, and a horizontal arm that reaches out over the marsh surface. For measurements, the SET apparatus is temporarily deployed by affixed to the SET receiver and ensuring the arm is horizonatally level. Surface elevation measurements are taken at nine equidistant locations along the arm, and the arm has typically four (but as many as eight) possible orientations. This allows for a minimum of 36 measurements taken at any given SET.  

A long narrow pin of a known length (see #4 in Figure 1) is inserted vertically through each of nine holes drilled through the arm. The observer then measures the height of each pin above the arm (#3 in Figure 1). The arm is then moved to another one of the directions around the SET mark and the process is repeated.  Any descriptive information pertinent to the measurements at each pin is also recorded (e.g., mounds or divots on the substrate such as crab burrows, or the sediment surface being difficult to interpret due to the pin being located in water).  


# Possibly clarify this paragraph a bit more  

The height of the sediment is then calculated by subtracting the measurement (M), #3 in Figure 1, from the Pin Length (PL) to get the distance from the top of arm to sediment surface.  Real-world elevation (not just a measured height) on the top of the arm is obtained from a measure of the elevation of the top of the rod or SET mark (#1 in Figure 1) and the Vertical Offset of SET (#2 in Figure 1) using high accuracy survey equipment. The elevation of the SET mark (1) plus the Vertical Offset of SET (2) equals the real world elevation of the SET arm.  Subtract the distance from top of the arm to sediment surface (M-PL) from the elevation of the arm to get the real-world elevation of the substrate surface.  

```{r, out.width = '10%', fig.cap = 'Figure 1. Example of a SET. Pin heights above the horizontal arm (A) are a proxy for the shape of the marsh surface (B) (adapted from Lynch et al. 2015).'}
knitr::include_graphics(here::here("img", "SET_diagr2_NPSprotocols.png"))
```

```{r, out.width = '5%', fig.cap = 'Figure 2. SET apparatus installed and observer taking measurement with meter stick atop the SET arm (photo credit Hudson River NERR).'}
knitr::include_graphics(here::here("img", "SET_measurement_creditHudsonRiverNERR.jpg"))
```


# Background Information  

# This paragraph could use some love too  

Many factors such as elevation, dominant vegetation community, even the stability of the rod, have an influence on the substrate elevation observations that are obtained at a particular SET. A description of the environmental context for each SET for each Reserve is stored in a metadata file along with the pin height measurement data. The most pertinent information for interpreting elevation trend data from a SET is then summarized in tables and graphs by the R scripts (see appendix for qa/qc codes). The graphs and visualizations of the data are used to assess accuracy and quality of the entered data, compare SETs, calculate rates of change in surface elevations over time and ultimately compare to changes in local sea level. Local rate of sea level change is obtained from NOAA’s National Water Level Observation Network (NWLON) for each Reserve. This document is the output from the scripts and the following data sections will be auto populated for each Reserve’s SET and water level data.  


```{r read-data}
# this chunk copied out of 005_rate_calculations.Rmd

# find the folder with processed data
path <- here::here('data', 'processed')

# in that folder, find the name of the file(s) that ends with 'set_processed.csv'
filelist <- dir(path, pattern = "set_processed.csv$")


# generate warnings if the folder is empty; if there are multiple matching files, select the first one
if (length(filelist) == 0) stop("There are no files of the correct name/format (---set_QC.csv) in your processed data folder.")

if (length(filelist) > 1) {
    warning("There is more than one file of the correct format (---set_QC.csv) in your data folder. The first file alphabetically will be used.")
    filelist <- filelist[1]
}

# generate the full path to the file; read it in and get pin heights to mm
filename <- paste0(path, "/", filelist)
dat <- read_csv(filename)
dat <- height_to_mm(dat)

# if there isn't a reserve column in the data,
# pull it from the file name
if(!exists("reserve", dat)){
  dat$reserve <- toupper(str_extract(filename, "[:alpha:]{3}(?=set)"))
} 

# get rid of any placeholders; make sure set_id is a factor;
# make sure reserve, station, arm_position, and pin_number are character vectors
# paste year, month, and day together into "date"
dat <- dat %>%
  mutate(date = lubridate::ymd(paste(year, month, day))) %>% 
  filter(!is.na(date),
         !is.na(pin_number)) %>%
  mutate_at(c("reserve", "set_id",   
              "arm_position", "arm_qaqc_code", 
              "pin_number", "qaqc_code"),
            as.character)

# trim the dataset based on user-specified dates
if(!is.na(opts_long$custom_start)){
  start <- lubridate::ymd(opts_long$custom_start)
  dat <- dat %>% 
    filter(date >= start)
}
if(!is.na(opts_long$custom_end)){
  end <- lubridate::ymd(opts_long$custom_end)
  dat <- dat %>% 
    filter(date <= end)
}
```

```{r trim-data}
if (excl_exist) {
  # find the rows to exclude - either arm or pin codes match
  pin_to_excl <- which(dat$qaqc_code %in% codes_to_exclude)
  arm_to_excl <- which(dat$arm_qaqc_code %in% codes_to_exclude)
  
  # make a data frame of the excluded ones and print it out
  to_excl <- c(pin_to_excl, arm_to_excl)
  excluded <- dat[to_excl, ]
  
  
  excluded %>% 
    select(set_id, date, 
           arm = arm_position, 
           arm_code = arm_qaqc_code, 
           pin_number, qaqc_code, pin_height) %>% 
    knit_print()
  

  # turn the heights into NAs
  dat$pin_height[to_excl] <- NA 
  
  # clean up
  # rm(list = c("excluded", "arm_to_excl", "pin_to_excl", "to_excl"))
}
```

```{r read-metadata, warning = TRUE}
# find the folder with metadata
path <- here::here('metadata')

# in that folder, find the name of the file(s) that ends with 'setm.csv'
filelist <- dir(path, pattern = 'set_metadata.xls')

# generate warnings if the folder is empty; if there are multiple matching files, select the first one
if (length(filelist) == 0) stop("There are no files of the correct name/format (---set_metadata.xls or .xlsx) in your metadata folder.")

if (length(filelist) > 1) {
    warning("There is more than one file of the correct format (---set_metadata.xls or .xlsx) in your metadata folder. The first file alphabetically will be used.")
    filelist <- filelist[1]
}

# generate the full path to the file; read it in, clean the names, get rid of empty rows and columns
filename <- paste0(path, "/", filelist)
mdat <- read_excel(filename) %>%
    janitor::clean_names() %>%
    janitor::remove_empty(which = "rows") %>% 
    mutate_at(c("unique_set_id", "user_friendly_set_name", "reserve"),
            as.character)
```

```{r verify-setid, warning = TRUE}
# first pull out set_id from both data frames
data_setid <- unique(as.character(dat$set_id))
metadata_setid <- unique(mdat$unique_set_id)

# find set_ids that are in the data, but not in the metadata
dat_not_m <- setdiff(data_setid, metadata_setid)
# find set_ids that are in the metadata, but not in the data
m_not_dat <- setdiff(metadata_setid, data_setid)

if (length(dat_not_m) > 0) {
    toprint <- paste(dat_not_m, collapse = ", ")
    warning(paste0("The following SET IDs exist in your data, but not in your metadata. Output may not match what you expect.", toprint))
}

if (length(m_not_dat) > 0) {
    toprint <- paste(m_not_dat, collapse = ", ")
    warning(paste0("The following SET IDs exist in your metadata, but not in your data. Output may not match what you expect.", toprint))
}

# go ahead and order the set_ids in dat and unique_set_id in mdat by the metadata's numerical_order, if available
# if this step is skipped, they should remain in character format
if (!anyNA(mdat$numerical_order)){
  mdat_sub <- select(mdat, unique_set_id, numerical_order) %>% 
    mutate(unique_set_id = factor(unique_set_id))
  dat <- dat %>% 
    mutate(set_id = factor(set_id)) %>% 
    left_join(., mdat_sub, by = c("set_id" = "unique_set_id")) %>% 
    mutate(set_id = fct_reorder(set_id, numerical_order)) %>% 
    select(-numerical_order)
  mdat <- mdat %>% 
    mutate(unique_set_id = factor(unique_set_id),
           unique_set_id = fct_reorder(unique_set_id, numerical_order))
  rm(mdat_sub)
}

# cleanup
rm(dat_not_m, m_not_dat, metadata_setid, data_setid, filelist, path)
```

```{r read-slr}
slr_file <- here::here('metadata', 'slr_rates.csv')
slr_rates <- read_csv(slr_file) %>%
    clean_names() %>%
    janitor::remove_empty(which = c("rows", "cols"))
```

```{r read-rates}
file_in <- here::here("data", "intermediate", "rate_summary.csv")
rate_summ <- read.csv(file_in, stringsAsFactors = FALSE) %>%
  mutate_at(c("reserve", "set_id",   
               "user_friendly_set_name",
              "co_dominant_species1"),
            as.character)
```

```{r verify-slr, warning = TRUE}
res_to_match <- unique(dat$reserve)

if (res_to_match %in% unique(slr_rates$reserve)) {
    slr_res <- slr_rates %>%
        filter(reserve == res_to_match) %>%
        select(-link)
    slr <- slr_res$slr_rate_mm_yr
    slr_ci <- slr_res$x95_percent_ci
} else {warning(paste("This reserve does not have an entry in the sea level rise rates file. Please check metadata/slr_rates.csv and enter a value using", res_to_match, "as the reserve code."))}
```



## Reserve-level context  


+  Local rate of sea level change is **`r slr`** +/- **`r slr_ci`** mm/yr.  
+  This rate is reported by `r slr_res$nearest_nwlon_station`, NWLON station number `r as.character(slr_res$nwlon_station_number)` based on data from *`r slr_res$data_start`* to *`r slr_res$data_end`*.
  

## SET-level characteristics  

### Setting  

# Clean up the language  

The first table produced from the R scripts provides a descriptive list of SETS at this reserve. The columns from left to right provide the SET code = a unique ID for the SET, SET name = a descriptive name for the SET, Type of SET = Deep or Shallow, and the Main Veg = dominant species vegetation at the SET.


```{r set-info-table}
# print the table
# what to print depends on whether lat/long are to be included

if(opts_long$coords_outreach == 1){
  mdat %>% 
    select(unique_set_id, user_friendly_set_name, set_type, latitude_dec_deg, 
           longitude_dec_deg, co_dominant_species1) %>% 
    arrange(unique_set_id) %>% 
    setNames(c("SET_code", "SET_name", "Type", "Lat", "Long", "Main_Veg")) %>% 
    flextable() %>% 
    theme_booktabs() %>% 
    autofit()
} else {
  mdat %>% 
    select(unique_set_id, user_friendly_set_name, set_type, co_dominant_species1) %>% 
    arrange(unique_set_id) %>% 
    setNames(c("SET_code", "SET_name", "Type", "Main_Veg")) %>% 
    flextable() %>% 
    theme_booktabs() %>% 
    autofit()
}
```



### Sampling Information  

The length of the observation period at a SET (how long it's been installed) and the frequency of sampling can be useful for evaluating the data. We might be more confident in a trend from a SET that has been measured for many years than we are in one that has only been measured for a few. Table 2 below gives a summary of the SETs at this reserve: the date the SET was first sampled, the date it was most recently sampled, how many years it has been sampled, and number of sample events (SETs may be sampled more or less frequently than once per year).

```{r sampling-info-table}
sample_info <- dat %>% 
  group_by(set_id) %>% 
  summarize(first_sampled = min(date),
            last_sampled = max(date),
            years_sampled = as.double(max(date) - min(date)) / 365.25,
            sample_events = length(unique(date))) 

sample_info %>% 
  flextable() %>% 
  theme_booktabs() %>% 
  autofit()
```



# Graphs  

```{r}
# do some manipulation of the data frame
# only use "user-friendly set id" in the following graphs

# pull out slr and the half-width of its confidence interval
slr <- unique(rate_summ$slr_rate)[[1]]
slr_ci <- unique(rate_summ$x95_percent_ci)[[1]]

# change some things in the data frame itself
rate_summ <- rate_summ %>% 
    mutate(user_friendly_set_name = case_when(!is.na(user_friendly_set_name) ~ user_friendly_set_name,
                                              TRUE ~ set_id)) %>% 
    rename(veg = co_dominant_species1) %>% 
    left_join(mdat[c("unique_set_id", "numerical_order")], by = c("set_id" = "unique_set_id")) 

  a <- forcats::fct_reorder(rate_summ$user_friendly_set_name,
                            desc(rate_summ$numerical_order))
  b <- forcats::fct_reorder(rate_summ$set_id,
                            desc(rate_summ$numerical_order))
  
  rate_summ$user_friendly_set_name <- a
  rate_summ$set_id2 <- b
```


## Change through time at each SET  


### Single SET  

Herein Figure 3 is a graph of data from a single SET at this reserve. Remember how we said there are 36 measurements on each date? Those have been averaged together, so we're looking at a single point for each date. The x-axis shows measurement date; as we move from left to right in the graph, we move through time. The y-axis shows the average position of the marsh surface relative to the first time measurements were taken at that SET. Is the marsh surface getting higher, lower, or staying the same at this SET?  

# Try to automate an answer  

# This is as far as I got incorporating the feedback  

```{r}
# find a SET for all these graphics
set_to_use <- unique(dat$set_id)[1]

# generate paths for the files  

# first = just points; no regression
p1 <- paste0("cumu_change_noLine_", set_to_use, ".png")
path1 <- here::here("R_output", "figures", "cumu_change_plots", "individual_sets", p1)

# second = points + regression
p2 <- paste0("cumu_change_withLine_", set_to_use, ".png")
path2 <- here::here("R_output", "figures", "cumu_change_plots", "individual_sets", p2)
  

# third = add in SLR line
p3 <- paste0("cumu_change_withLineAndSLR", set_to_use, ".png")
path3 <- here::here("R_output", "figures", "cumu_change_plots", "individual_sets", p3)

# fourth = simplify by removing points and making line representing measurements lighter
p4 <- paste0("cumu_change_linesOnly", set_to_use, ".png")
path4 <- here::here("R_output", "figures", "cumu_change_plots", "individual_sets", p4)
```

```{r}
knitr::include_graphics(path1)
```


Now, let's add a line. Is this an appropriate way to describe change at this SET?  

```{r}
knitr::include_graphics(path2)
```


What we really want to know is, how does the slope of that line compare to the slope of sea level rise? Is one steeper than the other? In the next graph, we add in a red line to represent change in sea level, based on the long-term rate calculated from a nearby tide station.    

```{r}
knitr::include_graphics(path3)
```


And finally, we simplify a bit by removing the points themselves, and only keeping the lines. It will become clear why we needed to simplify when we put all the SETs from this reserve together in one graphic.  

```{r}
knitr::include_graphics(path4)
```


### All SETs at this reserve  

Here is a birds-eye view of all SETs at this reserve! Does it look like SETs at this reserve are generally keeping up with sea level rise?    

```{r}
path5 <- here::here("R_output", "figures", "cumu_change_plots", "cumu_change_linesOnly.png")
knitr::include_graphics(path5)
```



## Comparisons to 0 and SLR  

First we will not color by vegetation. We'll start simple; with a vertical line at 0, another vertical line at the local rate of sea level rise (SLR), and a dot to represent the rate of change at each SET (rate of change increases from left to right on the x-axis):  

```{r, fig.width = 7, fig.height = 5}
p <- plot_rate_comps(data = rate_summ, plot_type = 1, 
                     set_ids = user_friendly_set_name, set_ci_low = CI_low,
                     set_ci_high = CI_high, 
                     comp1 = slr, 
                     comp1_ci_low = slr - slr_ci,
                     comp1_ci_high = slr + slr_ci,
                     rates = rate) 
print(p)
```

Of course, these calculated rates have some associated uncertainty. Here, we represent that with "whiskers":  

```{r, fig.width = 7, fig.height = 5}
p <- plot_rate_comps(data = rate_summ, plot_type = 2, 
                     set_ids = user_friendly_set_name, set_ci_low = CI_low,
                     set_ci_high = CI_high, 
                     comp1 = slr, 
                     comp1_ci_low = slr - slr_ci,
                     comp1_ci_high = slr + slr_ci,
                     rates = rate) 
print(p)
```

And: the calculated rate of sea level rise ALSO has some associated uncertainty. Here, that is represented by light blue shading:  

```{r, fig.width = 7, fig.height = 5}
p <- plot_rate_comps(data = rate_summ, plot_type = 3, 
                     set_ids = user_friendly_set_name, set_ci_low = CI_low,
                     set_ci_high = CI_high, 
                     comp1 = slr, 
                     comp1_ci_low = slr - slr_ci,
                     comp1_ci_high = slr + slr_ci,
                     rates = rate) 
print(p)
```



Now we'll do the same building up, but we *will* color the points by dominant vegetation around each SET:  

```{r, fig.width = 7, fig.height = 6}
p <- plot_rate_comps(data = rate_summ, plot_type = 1, 
                     set_ids = user_friendly_set_name, set_ci_low = CI_low,
                     set_ci_high = CI_high, 
                     comp1 = slr, 
                     comp1_ci_low = slr - slr_ci,
                     comp1_ci_high = slr + slr_ci,
                     rates = rate, color_by_veg = TRUE, veg = veg) +
    theme(legend.position = "bottom")
print(p)
```

Of course, these calculated rates have some associated uncertainty. Here, we represent that with "whiskers":  

```{r, fig.width = 7, fig.height = 5}
p <- plot_rate_comps(data = rate_summ, plot_type = 2, 
                     set_ids = user_friendly_set_name, set_ci_low = CI_low,
                     set_ci_high = CI_high, 
                     comp1 = slr, 
                     comp1_ci_low = slr - slr_ci,
                     comp1_ci_high = slr + slr_ci,
                     rates = rate, color_by_veg = TRUE, veg = veg) +
  theme(legend.position = "bottom")
print(p)
```

And: the calculated rate of sea level rise ALSO has some associated uncertainty. Here, that is represented by light blue shading:  

```{r, fig.width = 7, fig.height = 7}
p <- plot_rate_comps(data = rate_summ, plot_type = 3, 
                     set_ids = user_friendly_set_name, set_ci_low = CI_low,
                     set_ci_high = CI_high, 
                     comp1 = slr, 
                     comp1_ci_low = slr - slr_ci,
                     comp1_ci_high = slr + slr_ci,
                     rates = rate, color_by_veg = TRUE, veg = veg) +
  theme(legend.position = "bottom", legend.direction = "vertical")
print(p)
```


## On a map  

Where are the changes happening within the reserve? Do you see any spatial patterns? What could be the reasons for these, based on what you know about your reserve?  

### Compared to 0  

First, are the SETs generally gaining or losing elevation? We can look by comparing them to 0.  

```{r}
map_0_path <- here::here("R_output", "figures", "maps", "map_0.png")
knitr::include_graphics(map_0_path)
```


### Compared to SLR  

```{r}
map_SLR_path <- here::here("R_output", "figures", "maps", "map_SLR.png")
knitr::include_graphics(map_SLR_path)
```

